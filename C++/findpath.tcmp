int* Monster::findPath(Tile* target){

		//The origin is the tile our character is standing on.
		Tile* origin = getTile();
		//Give the origin a pathvalue that makes it recognizable
		//to our algorithm.
		origin->pathValue = -1;

		//Origin is now the current square.
		Tile* currentSquare = origin;
		//We clear off all of the pathValues that may be left over
		//from all tiles on the level.
		currentLevel->clearTileValues();
		//We have a stack of unexplored tiles that will be queued
		//to be explored.
		stack <Tile*> unexploredTiles;
		//we have a stack of directions that we will set our character's
		//path to, so that they can follow them to the target tile.
		stack <int[2]> directions;

		while(currentSquare != target){
			//make a list of adjacent tiles, and go through them to see
			//which ones we've explored
			list <Tile*> adjTiles = currentSquare->listAdjacentTiles();
				list<Tile*>::iterator tile;
				//for tile in adjTiles:
				for(tile = adjTiles.begin(); tile != adjTiles.end(); tile++){
				//If we're not going backwards specifically and 
				//the tile is something we can walk on, we assign it
				//a value
					if ((*tile)->terrain.passable && *tile != origin){
						//If the tile's path value is 0, the tile is unexplored.
						if ((*tile)->pathValue == 0){
							//If we're just starting, we have to initialize
							//the adjacent tiles at one (if we set the origin tile to 0
								//it causes problems)
							if (currentSquare == origin)
								(*tile)->pathValue = 1;
							else
								//We set the adjacent 0's to our current tile's path value
								//+1 this way we know how far every square is from the player
								(*tile)->pathValue = currentSquare->pathValue + 1;
							
							//We put all tiles who we've given a path value to
							//into the unexplored tiles list, if we don't find
							//our target next to us, we'll look through those tiles
							//and continue searching.
							unexploredTiles.push(*tile);

							//If the tile we're iterating over is the target, we're done
							//with this part of the algorithm
							if (*tile == target){
								currentSquare = *tile;
								break;
							}
						}
					}
				}
			//While we haven't found the target tile, and there are still unexplored
			//tiles left, iterate over them.
			if (0 < unexploredTiles.size() && currentSquare != target){
				currentSquare = unexploredTiles.top();
				unexploredTiles.pop();
			}
	}

/*
		
		//Then we start at the target tile, and work our way backwards
		//to find the origin, pushing the direction our character will
		//have to go onto the directions list
		while(currentSquare != origin):
			//Check adjacent tiles
			adjTiles = currentSquare.listAdjacentTiles(self.level.levelMap)
			for tile in adjTiles:
				//find a square adjacent to the current square that 
				//is one fewer spaces away from the origin square
				if tile.pathValue == currentSquare.pathValue - 1:
					//if we haven't found the origin, push
					//another set of directions onto the list
					if tile == origin or tile.pathValue > 0:
						y = currentSquare.yPos - tile.yPos 
						x = currentSquare.xPos - tile.xPos
						directions.append((y, x))
						//If the tile is the origin, we update
						//our character's directions, and quit the function
						if tile == origin:
							self.path = directions
							return 1
						//Otherwise we set this tile to the current tile, 
						//and start the process again
						currentSquare = tile
						break

*/
}